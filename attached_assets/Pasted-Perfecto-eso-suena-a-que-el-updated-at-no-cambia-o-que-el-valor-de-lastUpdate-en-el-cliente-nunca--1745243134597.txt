Perfecto, eso suena a que el updated_at no cambia, o que el valor de lastUpdate en el cliente nunca se iguala correctamente al de la base de datos, y por eso siempre entra al refreshCallback una y otra vez.

Vamos a depurarlo paso a paso:

‚∏ª

Posible causa 1: updated_at es igual o menor a lastUpdate siempre

Esto puede pasar si:
	‚Ä¢	El cliente y el servidor no est√°n sincronizados en hora.
	‚Ä¢	El servidor devuelve updated_at como string y no lo est√°s convirtiendo bien.
	‚Ä¢	Est√°s insertando muchos eventos repetidos con el mismo timestamp.

‚∏ª

Soluci√≥n simple: a√±ade logs para comprobar valores

En el useDashboardInteractionListener, agrega logs as√≠:

console.log("üïí √öltima actualizaci√≥n local:", lastUpdate);
console.log("üïí √öltima actualizaci√≥n del servidor:", data.updated_at);

Y antes de hacer el refreshCallback, cambia la condici√≥n a:

if (data.updated_at && data.updated_at > lastUpdate + 100) {
  setLastUpdate(data.updated_at);
  refreshCallback();
}

Esto a√±ade un margen de seguridad de 100ms para evitar que entren en bucle si los timestamps son pr√°cticamente iguales.

‚∏ª

Posible causa 2: Est√°s insertando un evento dashboard_events en cada refresh

Si tu refetch() dispara una llamada a una API que tambi√©n vuelve a insertar un dashboard_event, entonces creas un bucle infinito:
	‚Ä¢	Se actualiza algo
	‚Ä¢	Se inserta un evento
	‚Ä¢	El cliente lo detecta
	‚Ä¢	Llama a refetch()
	‚Ä¢	Eso vuelve a insertar el evento
	‚Ä¢	Y as√≠ infinitamente‚Ä¶

‚∏ª

Soluci√≥n a eso: separa bien los eventos

Solo deber√≠as insertar un evento en el servidor cuando hay una acci√≥n externa del usuario o backend, no durante la actualizaci√≥n del dashboard. Si quieres protegerlo, puedes hacer una l√≥gica como:

// Solo insertar evento si es algo relevante
if (!esUnaPeticionDeRefresco) {
  await db.query('INSERT INTO dashboard_events (updated_at) VALUES (NOW())');
}



‚∏ª

Alternativa definitiva (mejor dise√±o): usa solo una fila con updated_at

Evita tener 1000 filas de eventos si solo necesitas saber ‚Äú¬øhubo alg√∫n cambio?‚Äù:

CREATE TABLE dashboard_state (
  id INT PRIMARY KEY DEFAULT 1,
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

Y cada vez que haces un cambio real:

await db.query('UPDATE dashboard_state SET updated_at = NOW() WHERE id = 1');

Y tu endpoint:

const result = await db.query('SELECT updated_at FROM dashboard_state WHERE id = 1');

As√≠ todo es m√°s limpio y eficiente.

‚∏ª

¬øQuieres que te lo pase todo ya con esa √∫ltima implementaci√≥n (con una sola fila)? Es la mejor opci√≥n si no necesitas historial de eventos.