import { useQuery } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { DashboardStats } from "@/lib/types";

// Endpoint para obtener datos directos del dashboard (m√°s optimizado)
const DASHBOARD_DIRECT_ENDPOINT = "/api/dashboard-direct";

// Funci√≥n auxiliar para generar un valor aleatorio (evitar cach√©)
const generateRandomString = () => Math.random().toString(36).substring(2, 15);

// Funci√≥n auxiliar para obtener datos frescos del servidor (creada fuera de la funci√≥n principal)
const fetchDashboardData = async (
  endpoint: string, 
  year: string, 
  period: string, 
  trigger: number
): Promise<DashboardStats> => {
  const cacheKey = `dashboard_cache_${year}_${period}`;
  
  // Crear una URL con par√°metros expl√≠citos y una marca de tiempo aleatoria para evitar cach√©
  const randomParam = generateRandomString();
  const url = `${endpoint}?year=${year}&period=${period}&forceRefresh=true&random=${randomParam}`;
  
  // Obtener el timestamp actual para prevenir a√∫n m√°s el cach√©
  const timestamp = new Date().getTime();
  const urlWithTimestamp = `${url}&_t=${timestamp}`;
  
  console.log("üîç SOLICITUD A ENDPOINT DIRECTO:", urlWithTimestamp);
  
  // Incluir los par√°metros de filtro en la URL y headers adicionales
  const data = await fetch(urlWithTimestamp, {
    credentials: "include", // Importante: incluir las cookies en la petici√≥n
    headers: { 
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0',
      'X-Refresh-Trigger': trigger.toString(), // Enviamos el refreshTrigger como header
      'X-Dashboard-Year': year, // A√±adimos a√±o como header para facilitar depuraci√≥n
      'X-Dashboard-Period': period, // A√±adimos periodo como header para facilitar depuraci√≥n
      'X-Force-Refresh': 'true', // Header adicional para indicar que es un refresco forzado
      'X-Random': randomParam // Header adicional para evitar cach√©
    }
  }).then(res => {
    if (!res.ok) {
      throw new Error(`Error al cargar datos: ${res.status}`);
    }
    return res.json();
  });
  
  // Guardar los datos en sessionStorage para futuras consultas
  try {
    sessionStorage.setItem(cacheKey, JSON.stringify(data));
    console.log(`üíæ Datos guardados en cach√© local para ${year}/${period}`);
  } catch (error) {
    console.warn('No se pudo guardar los datos en cach√©:', error);
  }
  
  // Resetear la bandera de forzar refresco
  window.forceDashboardRefresh = false;
  
  console.log(`‚úÖ Datos actualizados del dashboard (${year}/${period}) cargados correctamente`);
  return data;
};

export function useDashboardData(
  year: string | undefined = new Date().getFullYear().toString(),
  period: string | undefined = "all",
  trigger: number = Date.now()
) {
  const [previousData, setPreviousData] = useState<DashboardStats | null>(null);
  
  // Asegurarse de que los valores sean v√°lidos o usar valores predeterminados
  const finalYear = year || new Date().getFullYear().toString();
  const finalPeriod = period || "all";
  
  // Endpoint optimizado que responde m√°s r√°pido
  const endpoint = DASHBOARD_DIRECT_ENDPOINT;
  
  // Depuraci√≥n inicial
  useEffect(() => {
    console.log("üìä useDashboardData: Detectado cambio en refreshTrigger:", trigger);
    console.log("üìä CONECTANDO A ENDPOINT DIRECTO: a√±o=" + finalYear + ", periodo=" + finalPeriod + " [" + trigger + "]...");
  }, [finalYear, finalPeriod, trigger]);
  
  const dashboardQuery = useQuery<DashboardStats>({
    queryKey: [endpoint, finalYear, finalPeriod, trigger],
    queryFn: async () => {
      // Validaciones b√°sicas para prevenir errores
      if (!finalYear) {
        throw new Error("A√±o no definido en la solicitud del dashboard");
      }
      
      try {
        // Guardar la clave de cach√© actual para su uso en polling
        const cacheKey = `dashboard_cache_${finalYear}_${finalPeriod}`;
        sessionStorage.setItem('current_dashboard_cache_key', cacheKey);
        
        // Verificar si hay datos en cach√© que podemos usar mientras se carga
        let cachedData = null;
        const cachedString = sessionStorage.getItem(cacheKey);
        
        if (cachedString) {
          try {
            cachedData = JSON.parse(cachedString);
            // Si tenemos datos en cach√© y es una actualizaci√≥n de fondo (no forzada),
            // devolver inmediatamente los datos en cach√©
            if (cachedData && !window.forceDashboardRefresh) {
              console.log(`üöÄ Usando cach√© existente para ${finalYear}/${finalPeriod} mientras se actualiza en segundo plano`);
              
              // Actualizar en segundo plano sin bloquear la interfaz
              setTimeout(() => {
                fetchDashboardData(endpoint, finalYear, finalPeriod, trigger)
                  .catch(e => console.error('Error en actualizaci√≥n en segundo plano:', e));
              }, 300);
              
              return cachedData;
            }
          } catch (e) {
            console.warn('Error al parsear datos en cach√©:', e);
          }
        }
        
        // Si no hay datos en cach√© o se fuerza la actualizaci√≥n, obtener datos frescos
        return await fetchDashboardData(endpoint, finalYear, finalPeriod, trigger);
      } catch (error) {
        console.error("‚ùå Error al cargar datos del dashboard:", error);
        
        // Proporcionar una estructura de datos base para que la UI no falle
        return {
          income: 0,
          expenses: 0,
          pendingInvoices: 0,
          pendingCount: 0,
          baseImponible: 0,
          baseImponibleGastos: 0,
          balance: 0,
          result: 0,
          netIncome: 0,
          netExpenses: 0,
          netResult: 0,
          taxes: {
            vat: 0,
            incomeTax: 0,
            ivaALiquidar: 0
          },
          taxStats: {
            ivaRepercutido: 0,
            ivaSoportado: 0,
            ivaLiquidar: 0,
            irpfRetenido: 0,
            irpfTotal: 0,
            irpfPagar: 0
          },
          year: finalYear,
          period: finalPeriod
        };
      }
    },
    refetchOnWindowFocus: true // Ahora s√≠ refrescamos al cambiar el foco para obtener datos actualizados
  });

  // Depuraci√≥n
  if (dashboardQuery.data) {
    console.log("Dashboard stats", {
      income: dashboardQuery.data.income,
      expenses: dashboardQuery.data.expenses,
      baseImponible: dashboardQuery.data.baseImponible,
      result: dashboardQuery.data.result
    });
  }

  return {
    data: dashboardQuery.data,
    isLoading: dashboardQuery.isLoading,
    isError: dashboardQuery.isError,
    refetch: dashboardQuery.refetch
  };
}